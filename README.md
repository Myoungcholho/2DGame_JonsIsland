# 📘Unity2D 퍼즐 게임
<br>
<img align="right" width="420"
     src="https://github.com/user-attachments/assets/f5417f7f-965c-480e-b750-51ccd691b86e"
     alt="Unity 2D" />


- 소개 영상: [포트폴리오 영상](https://www.youtube.com/watch?v=CVj2y5PXsnw)
- 개발 기간: 2023.04.11 ~ 2023.10.11 (184일)
- 개발 인원: 5명 (팀장 - 기획 및 기능 개발, 팀원 역할 분배)
- 핵심 요약: 유니티 엔진을 활용한 2D 퍼즐 게임
- 게임 진행 가이드 및 배포 파일: [링크](https://github.com/Geonwoo1472/Tutorial-1-1)
- 개발 환경:
  - 언어: C#
  - 엔진: Unity

<br clear="both"/>

# 📘목차
- [개발 계기](#개발-계기)
- [아쉬웠던 점](#아쉬웠던-점)
- [프로젝트에서 얻은 것](#프로젝트에서-얻은-것)
- [구현 내용](#구현-내용)
- [문제 해결 경험(트러블 슈팅)](#문제-해결-경험트러블-슈팅)
- [프로젝트 코드](#프로젝트-코드)

# 📘개발 계기
### 플레이어에서 개발자로

특히 인상 깊게 즐겼던 「OMORI」의 영향을 받아,  
쯔꾸르 스타일의 게임을 기반으로 하되,  
퍼즐 요소를 강화한 새로운 형태로 재해석해 보고자 했습니다.


# 📘아쉬웠던 점

**요약**
- [1. 스크립트 분리 방식과 컴포넌트 기반 설계 부족](#weak-arch)
- [2. 불필요한 Update 의존 구조](#weak-optim)

---

### 1. 스크립트 분리 방식과 컴포넌트 기반 설계 부족 <a id="weak-arch"></a>

스크립트를 기능별로 잘게 나누며 개발했지만,  
프로젝트가 커지면서 중복과 재사용성 문제를 겪었습니다.

인터페이스와 공통 컴포넌트 기반으로 설계했더라면  
더 확장성 있는 구조가 되었을 것이라 아쉽게 느꼈습니다.

이 경험을 바탕으로 이후 진행한 3D 프로젝트에서는  
초기 설계 단계부터 이러한 점을 고려해 구조를 잡았습니다.

---

### 2. 불필요한 Update 의존 구조 <a id="weak-optim"></a>

UI 갱신이나 아이템 획득처럼 특정 시점에만 필요한 로직도,  
습관적으로 Update()에서 매 프레임 체크하도록 구현한 적이 있습니다.

프로파일링과 리팩터링을 거쳐 이벤트 기반 호출로 바꾸면서,  
더 구조적인 설계가 가능하다는 것을 느꼈고,  

이후에는 "정말 매 프레임 돌 필요가 있는 로직인가?"를 먼저 고민하며  
이벤트/콜백 기반으로 작성하는 습관의 계기가 되었습니다.

# 📘프로젝트에서 얻은 것

**요약**
- [1. 팀 단위 프로젝트 운영 역량](#project01)
- [2. 전체적인 게임 프로세스와 라이프사이클 이해](#project02)
- [3. 언어 차원에서의 객체지향 이해와 실력 향상](#project03)

---

### 1. 팀 단위 프로젝트 운영 역량 <a id="project01"></a>

팀으로 개발을 진행하며 마감 기한, 역할 분배, 회의 정리, 코드 공유 방식 등  
개발 외적인 여러 문제에도 자연스럽게 부딪히게 되었습니다.

이 과정에서 규칙을 정하고 회의록과 정리 문서를 남기며 협업 방식을 다듬었고,  
팀 프로젝트를 더 효율적으로 운영하는 방법을 몸으로 배울 수 있었습니다.

---

### 2. 전체적인 게임 프로세스와 라이프사이클 이해 <a id="project02"></a>

처음에는 단순히 "로직 → 렌더링" 흐름 정도만 이해하고 있었지만,  
엔진을 활용해 개발하면서 Awake, Start, OnEnable, Update, FixedUpdate, Tick 등  
여러 생명주기를 직접 다뤄 보게 되었습니다.

이를 통해 엔진이 프레임 단위로 게임을 어떻게 구동하는지 체감했고,  
각 콜백이 왜 분리되어 있는지, 어떤 책임을 맡는 것이 적절한지  
고민해 볼 수 있는 계기가 되었습니다.

---

### 3. 언어 차원에서의 객체지향 이해와 실력 향상 <a id="project03"></a>

프로젝트를 시작할 당시에는 객체지향에 대한 이해가 얕은 편이었습니다.

하지만 개발을 진행하면서 반복되는 코드를 공통화하거나  
재사용 가능한 구조로 바꾸는 등,  
객체지향적인 설계를 적용해 보려는 시도를 계속하게 되었습니다.

이 경험을 통해 언어와 문법을 단순히 "사용하는 수준"을 넘어,  
구조를 설계하고 개선하는 방향으로 사고하는 연습을 할 수 있었습니다.


# 📘구현 내용

- 플레이어 상호작용  
  - 대화, 인터랙션 오브젝트, 박스 밀기, 1회성 이동 트리거, 덫, 탈출 기믹 등

- 게임 시스템  
  - 스태미나, 아이템 사용/획득, 오브젝트 파괴, 시야 제한(라이트/시야 연출), 스테이지 전환

- UI · 사운드 · 저장  
  - 키 설정 / 사운드 설정
  - 화면 UI, 인벤토리, 미니맵·지도
  - JSON 기반 세이브 / 로드 시스템

# 📘문제 해결 경험(트러블 슈팅)

**요약**
- [1. Delegate 해제 시점 오류로 인한 MissingReferenceException](#tag01)
- [2. Canvas UI 가려지지 않는 문제 & 렌더링 순서 이해 부족](#tag02)
- [3. Prefab Override 문제로 인한 데이터 불일치](#tag03)

### 1. Delegate 해제 시점 오류로 인한 MissingReferenceException <a id="tag01"></a>

- 문제 상황  

  오브젝트를 비활성화한 뒤 다시 활성화할 때,  
  남아 있던 Delegate 연결로 인해 `MissingReference` 예외가 발생했습니다.

- 원인 분석  

  이벤트 해제를 `OnDestroy()`에서만 처리했지만,  
  실제로는 `Destroy`가 아닌 `SetActive(false)`로 비활성화가 이루어져  
  `OnDestroy()`가 호출되지 않는 구조였습니다.

- 해결

  이벤트 해제를 `OnDisable()`에서 진행하고,  
  이벤트 등록을 `OnEnable()`에 배치해 라이프사이클에 맞게 재설계했습니다.

- 배운 점  

  Unity 객체 라이프사이클과 이벤트 해제 시점의 중요성을 이해했고,  
  이후에는 "이벤트 연결·해제 타이밍이 명확한 설계"를  
  우선적으로 고려하게 되었습니다.


---

### 2. Canvas UI 가려지지 않는 문제 & 렌더링 순서 이해 부족 <a id="tag02"></a>

- 문제 상황  

  화면 전체를 덮는 페이드 연출을 구현할 때,  
  일부 UI가 페이드 레이어에 가려지지 않는 문제가 발생했습니다.

- 원인 분석  

  Canvas의 Render Mode, Sorting Order, Canvas 그룹 구조를 고려하지 않고  
  모든 UI를 하나의 Canvas에 배치한 것이 원인이었습니다.

- 해결  

  Frame Debugger와 Rendering Statistics를 활용해
  Canvas 전체가 재렌더링되는 구조를 분석했고,  
  UI 역할별로 Canvas를 분리하고 Sorting Order를 재설계해 문제를 해결했습니다.

- 배운 점  

  Canvas는 단순 UI 컨테이너가 아니라 렌더링 비용과 순서가 중요한 구조이며,  
  UI는 기능과 갱신 주기 기준으로 분리하는 것이  
  성능과 유지보수 측면에서 매우 중요하다는 것을 배웠습니다.

---

### 3. Prefab Override 문제로 인한 데이터 불일치 <a id="tag03"></a>

- 문제 상황  

  Prefab을 여러 씬에서 초기화해 사용하다가 값이 엉키고,  
  어떤 값이 원본인지 구분하기 어려운 문제가 발생했습니다.

- 원인 분석  

  Prefab Override 개념을 충분히 고려하지 않고,  
  씬에서 개별 수정으로 관리하려 했던 구조적 실수였습니다.

- 해결  

  "원본 Prefab / Variant Prefab / Scene Instance" 구조로 재정의하고,  
  공통 값과 개별 값을 분리해 관리하도록 개선했습니다.

- 배운 점

  Prefab은 단순 복사가 아니라 상속에 가까운 구조이며,  
  여러 씬에서 재사용되는 요소는  
  초기에 명확한 관리 체계가 필요하다는 것을 배웠습니다.

# 📘프로젝트 코드
- [프로젝트-코드](https://github.com/Myoungcholho/2DGame_JonsIsland/tree/main/Assets/Script)
